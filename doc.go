// Package flume is a logging package, intended to replace logxi, and build on top of zap.
//
// Motivations
//
// - structured: log entries can have key/value properties attached to them
// - leveled: log entries have a level (error, info, debug).  Loggers can be configured to
//   drop entries below a certain level.
// - named: loggers have a name.  Levels can be configured for each named logger.  For example, enable
//   debug logging in particular packages.
// - All logging is turned off by default.
// - Fewer log levels:
//
//       - Error: Something that would be reported up to an error reporting service
//       - Info: High priority, low volume messages. Appropriate for production runtime use.  Used for coarse-grained
//         feedback
//       - Debug: Slow, verbose logging, not appropriate for long-term production use
//
//   Warns should just be errors or infos.  Trace should just be debug.  Panics and Fatals are not supported.  If you want
//   to panic or exit, don't lean on your logging package to do it.
// - Global, dynamic configuration: All flume loggers are registered with an internal global registry when they are
//   created, even loggers created by 3rd party packages.  Your program's entry point (either main(), or tests)
//   can configure all those loggers, even if the loggers were created in 3rd party code.  This means loggers can be used
//   anywhere in code, but the entry point still has complete, global control over all log output.
//
// Features
//
// - built on top of zap.  zap is not exported, but zap Encoders and Fields can be used.
// - Supports JSON, LTSV, and colorized console output formats
// - optional call site logging (file and line number of log call)
// - output can be directed to any writer, defaults to stdout
// - includes an adapter to direct logs to testing.T.Log()
// - supports creating child loggers with pre-set context: `Logger.With()`
// - levels can be configured via a single string, which is convenient for configuration via env var, see `LevelsString()`
//
// advantages over loxgi:
//
// - can be configured at runtime (logxi can only be configured at init time via env var).
// - doesn't print noisy full stacktraces for err and warn messages
// - output can be redirected to anything, include the test log
// - better handling multi-line messages and values (obsoleting yugo.MultilineLogArg)
//
// To migrate from logxi, replace `import "github.com/mgutz/logxi/v1"` with
// `import "gitlab.protectv.local/ncryptify/yugo.git/flume`.
//
// This package does not offer package level log functions, so you need to create a logger instance first.  If you
// were using the logxi package-level functions, then you have calls like this in your code:
//
//     log.Info(...)
//
// `log` is referring to the logxi package.  To avoid rewriting these lines, create a package-level variable holding
// a logger instance:
//
//     var log = flume.New("mypkg")
//
// Try building.  Compile might fail if your package uses some of the deprecated log levels, like Trace and Warn.  To
// get it building, change the above line to:
//
//     var log = flume.NewDeprecated("mypkg")
//
// Then migrate away from those deprecated methods before switching back.
//
// To configure logging settings, call configuration functions from main() or from the beginning of your test:
//
//     flume.LevelsString(os.Getenv("LOGXI"))
//     flume.SetAddCaller(true)
//     flume.SetEncoder(NewColorizedConsoleEncoder(...))
//
// Test Support
//
// `flumetest` is a package for suppressing application logging during tests.  All application logs before or
// in between tests are discard.  Application logs during tests are buffered.  If the test succeeds, the logs
// are discarded. If the test failed, the accumulated logs are forward to t.Log()
//
//     func init() {
//         // sets a typical flume config for tests, enabling all levels, and setting a format which
//         // works well with t.Log().  This also configures flume to discard all logs: this ensures
//         // your go test output is not polluted with application logs generated by test initialization
//         // or setup code
//         flumetest.SetTestDefaults()
//     }
//
//     func MyTest(t *testing.T) {
//         // buffers application logs.  If test fails, accumulated logs are forwarded
//         // to t.Log()
//         defer flumetest.Start(t)()
//         ...
//     }
//
// tl;dr
//
// The implementation is a wrapper around zap.   zap does levels, structured logs, and is very fast.
// zap doesn't do centralized, global configuration, so this package
// adds that by maintaining an internal registry of all loggers, and using the sync.atomic stuff to swap out
// levels and writers in a thread safe way.
package flume
